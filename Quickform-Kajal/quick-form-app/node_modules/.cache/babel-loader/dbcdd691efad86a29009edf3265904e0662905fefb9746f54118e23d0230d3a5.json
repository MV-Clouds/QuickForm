{"ast":null,"code":"'use client';\n\n/**\n * interactive elements should be skiped\n * */\nvar INTERACTIVE_ELEMENTS = ['A', 'BUTTON', 'INPUT', 'OPTION', 'TEXTAREA', 'SELECT'];\nexport function isContainInteractiveElement(targetNode) {\n  return INTERACTIVE_ELEMENTS.includes(targetNode.tagName) || targetNode.contentEditable === 'true';\n}\nexport function setInlineStyles(node, styles) {\n  if (node !== null && styles !== null) {\n    for (var _i = 0, _Object$entries = Object.entries(styles); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n      node.style[key] = value;\n    }\n  }\n}\nexport function setTranslate3d(node, translate) {\n  setInlineStyles(node, {\n    transform: translate ? \"translate3d(\" + translate.x + \"px,\" + translate.y + \"px,0)\" : ''\n  });\n}\nexport function setTransitionDuration(node, duration) {\n  setInlineStyles(node, {\n    transitionDuration: duration ? duration + \"ms\" : ''\n  });\n}\n\n/**\n * find closest target node from source node\n * */\nexport function closestNode(sourceNode, judge) {\n  var currentNode = sourceNode;\n  while (currentNode) {\n    if (judge(currentNode)) {\n      return currentNode;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nexport function getEdgeOffset(node, parent, offset) {\n  if (offset === void 0) {\n    offset = {\n      left: 0,\n      top: 0\n    };\n  }\n  if (!node || !parent) {\n    return {};\n  }\n\n  // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n  var nodeOffset = {\n    left: (offset.left || 0) + node.offsetLeft,\n    top: (offset.top || 0) + node.offsetTop\n  };\n  if (node.parentNode === parent) {\n    return nodeOffset;\n  }\n  return getEdgeOffset(node.parentNode, parent, nodeOffset);\n}\nexport function getScrollingParent(el) {\n  if (!el || typeof window === 'undefined' || !window.getComputedStyle) {\n    return null;\n  }\n  try {\n    return closestNode(el, function (el) {\n      var computedStyle = window.getComputedStyle(el);\n      var overflowRegex = /(auto|scroll)/;\n      var properties = ['overflow', 'overflowX', 'overflowY'];\n      return properties.some(function (property) {\n        return overflowRegex.test(computedStyle[property]);\n      });\n    });\n  } catch (error) {\n    // In test environments, errors may occur, so return null\n    return null;\n  }\n}","map":{"version":3,"names":["INTERACTIVE_ELEMENTS","isContainInteractiveElement","targetNode","includes","tagName","contentEditable","setInlineStyles","node","styles","_i","_Object$entries","Object","entries","length","_Object$entries$_i","key","value","style","setTranslate3d","translate","transform","x","y","setTransitionDuration","duration","transitionDuration","closestNode","sourceNode","judge","currentNode","parentNode","getEdgeOffset","parent","offset","left","top","nodeOffset","offsetLeft","offsetTop","getScrollingParent","el","window","getComputedStyle","computedStyle","overflowRegex","properties","some","property","test","error"],"sources":["C:/Users/MVclouds/Desktop/QuickForm/Merged Mapping QF/QuickForm/QuickForm-Romit-Kajal-Merge/quick-form-app/node_modules/rsuite/esm/List/helper/utils.js"],"sourcesContent":["'use client';\n/**\n * interactive elements should be skiped\n * */\nvar INTERACTIVE_ELEMENTS = ['A', 'BUTTON', 'INPUT', 'OPTION', 'TEXTAREA', 'SELECT'];\nexport function isContainInteractiveElement(targetNode) {\n  return INTERACTIVE_ELEMENTS.includes(targetNode.tagName) || targetNode.contentEditable === 'true';\n}\nexport function setInlineStyles(node, styles) {\n  if (node !== null && styles !== null) {\n    for (var _i = 0, _Object$entries = Object.entries(styles); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n      node.style[key] = value;\n    }\n  }\n}\nexport function setTranslate3d(node, translate) {\n  setInlineStyles(node, {\n    transform: translate ? \"translate3d(\" + translate.x + \"px,\" + translate.y + \"px,0)\" : ''\n  });\n}\nexport function setTransitionDuration(node, duration) {\n  setInlineStyles(node, {\n    transitionDuration: duration ? duration + \"ms\" : ''\n  });\n}\n\n/**\n * find closest target node from source node\n * */\nexport function closestNode(sourceNode, judge) {\n  var currentNode = sourceNode;\n  while (currentNode) {\n    if (judge(currentNode)) {\n      return currentNode;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nexport function getEdgeOffset(node, parent, offset) {\n  if (offset === void 0) {\n    offset = {\n      left: 0,\n      top: 0\n    };\n  }\n  if (!node || !parent) {\n    return {};\n  }\n\n  // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n  var nodeOffset = {\n    left: (offset.left || 0) + node.offsetLeft,\n    top: (offset.top || 0) + node.offsetTop\n  };\n  if (node.parentNode === parent) {\n    return nodeOffset;\n  }\n  return getEdgeOffset(node.parentNode, parent, nodeOffset);\n}\nexport function getScrollingParent(el) {\n  if (!el || typeof window === 'undefined' || !window.getComputedStyle) {\n    return null;\n  }\n  try {\n    return closestNode(el, function (el) {\n      var computedStyle = window.getComputedStyle(el);\n      var overflowRegex = /(auto|scroll)/;\n      var properties = ['overflow', 'overflowX', 'overflowY'];\n      return properties.some(function (property) {\n        return overflowRegex.test(computedStyle[property]);\n      });\n    });\n  } catch (error) {\n    // In test environments, errors may occur, so return null\n    return null;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}