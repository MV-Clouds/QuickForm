{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport Metadata, { validateMetadata } from './metadata.js';\nimport isPossibleNumber from './isPossible.js';\nimport isValidNumber from './isValid.js'; // import checkNumberLength from './helpers/checkNumberLength.js'\n\nimport getNumberType from './helpers/getNumberType.js';\nimport getPossibleCountriesForNumber from './helpers/getPossibleCountriesForNumber.js';\nimport extractCountryCallingCode from './helpers/extractCountryCallingCode.js';\nimport isObject from './helpers/isObject.js';\nimport formatNumber from './format.js';\nvar USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;\nvar PhoneNumber = /*#__PURE__*/function () {\n  /**\r\n   * @param  {string} countryOrCountryCallingCode\r\n   * @param  {string} nationalNumber\r\n   * @param  {object} metadata — Metadata JSON\r\n   * @return {PhoneNumber}\r\n   */\n  function PhoneNumber(countryOrCountryCallingCode, nationalNumber, metadata) {\n    _classCallCheck(this, PhoneNumber);\n\n    // Validate `countryOrCountryCallingCode` argument.\n    if (!countryOrCountryCallingCode) {\n      throw new TypeError('First argument is required');\n    }\n    if (typeof countryOrCountryCallingCode !== 'string') {\n      throw new TypeError('First argument must be a string');\n    } // In case of public API use: `constructor(number, metadata)`.\n    // Transform the arguments from `constructor(number, metadata)` to\n    // `constructor(countryOrCountryCallingCode, nationalNumber, metadata)`.\n\n    if (typeof countryOrCountryCallingCode === 'string') {\n      if (countryOrCountryCallingCode[0] === '+' && !nationalNumber) {\n        throw new TypeError('`metadata` argument not passed');\n      }\n      if (isObject(nationalNumber) && isObject(nationalNumber.countries)) {\n        metadata = nationalNumber;\n        var e164Number = countryOrCountryCallingCode;\n        if (!E164_NUMBER_REGEXP.test(e164Number)) {\n          throw new Error('Invalid `number` argument passed: must consist of a \"+\" followed by digits');\n        }\n        var _extractCountryCallin = extractCountryCallingCode(e164Number, undefined, undefined, metadata),\n          _countryCallingCode = _extractCountryCallin.countryCallingCode,\n          number = _extractCountryCallin.number;\n        nationalNumber = number;\n        countryOrCountryCallingCode = _countryCallingCode;\n        if (!nationalNumber) {\n          throw new Error('Invalid `number` argument passed: too short');\n        }\n      }\n    } // Validate `nationalNumber` argument.\n\n    if (!nationalNumber) {\n      throw new TypeError('`nationalNumber` argument is required');\n    }\n    if (typeof nationalNumber !== 'string') {\n      throw new TypeError('`nationalNumber` argument must be a string');\n    } // Validate `metadata` argument.\n\n    validateMetadata(metadata); // Initialize properties.\n\n    var _getCountryAndCountry = getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadata),\n      country = _getCountryAndCountry.country,\n      countryCallingCode = _getCountryAndCountry.countryCallingCode;\n    this.country = country;\n    this.countryCallingCode = countryCallingCode;\n    this.nationalNumber = nationalNumber;\n    this.number = '+' + this.countryCallingCode + this.nationalNumber; // Exclude `metadata` property output from `PhoneNumber.toString()`\n    // so that it doesn't clutter the console output of Node.js.\n    // Previously, when Node.js did `console.log(new PhoneNumber(...))`,\n    // it would output the whole internal structure of the `metadata` object.\n\n    this.getMetadata = function () {\n      return metadata;\n    };\n  }\n  _createClass(PhoneNumber, [{\n    key: \"setExt\",\n    value: function setExt(ext) {\n      this.ext = ext;\n    }\n  }, {\n    key: \"getPossibleCountries\",\n    value: function getPossibleCountries() {\n      if (this.country) {\n        return [this.country];\n      }\n      return getPossibleCountriesForNumber(this.countryCallingCode, this.nationalNumber, this.getMetadata());\n    }\n  }, {\n    key: \"isPossible\",\n    value: function isPossible() {\n      return isPossibleNumber(this, {\n        v2: true\n      }, this.getMetadata());\n    }\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      return isValidNumber(this, {\n        v2: true\n      }, this.getMetadata());\n    }\n  }, {\n    key: \"isNonGeographic\",\n    value: function isNonGeographic() {\n      var metadata = new Metadata(this.getMetadata());\n      return metadata.isNonGeographicCallingCode(this.countryCallingCode);\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(phoneNumber) {\n      return this.number === phoneNumber.number && this.ext === phoneNumber.ext;\n    } // This function was originally meant to be an equivalent for `validatePhoneNumberLength()`,\n    // but later it was found out that it doesn't include the possible `TOO_SHORT` result\n    // returned from `parsePhoneNumberWithError()` in the original `validatePhoneNumberLength()`,\n    // so eventually I simply commented out this method from the `PhoneNumber` class\n    // and just left the `validatePhoneNumberLength()` function, even though that one would require\n    // and additional step to also validate the actual country / calling code of the phone number.\n    // validateLength() {\n    // \tconst metadata = new Metadata(this.getMetadata())\n    // \tmetadata.selectNumberingPlan(this.countryCallingCode)\n    // \tconst result = checkNumberLength(this.nationalNumber, metadata)\n    // \tif (result !== 'IS_POSSIBLE') {\n    // \t\treturn result\n    // \t}\n    // }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return getNumberType(this, {\n        v2: true\n      }, this.getMetadata());\n    }\n  }, {\n    key: \"format\",\n    value: function format(_format, options) {\n      return formatNumber(this, _format, options ? _objectSpread(_objectSpread({}, options), {}, {\n        v2: true\n      }) : {\n        v2: true\n      }, this.getMetadata());\n    }\n  }, {\n    key: \"formatNational\",\n    value: function formatNational(options) {\n      return this.format('NATIONAL', options);\n    }\n  }, {\n    key: \"formatInternational\",\n    value: function formatInternational(options) {\n      return this.format('INTERNATIONAL', options);\n    }\n  }, {\n    key: \"getURI\",\n    value: function getURI(options) {\n      return this.format('RFC3966', options);\n    }\n  }]);\n  return PhoneNumber;\n}();\nexport { PhoneNumber as default };\nvar isCountryCode = function isCountryCode(value) {\n  return /^[A-Z]{2}$/.test(value);\n};\nfunction getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadataJson) {\n  var country;\n  var countryCallingCode;\n  var metadata = new Metadata(metadataJson); // If country code is passed then derive `countryCallingCode` from it.\n  // Also store the country code as `.country`.\n\n  if (isCountryCode(countryOrCountryCallingCode)) {\n    country = countryOrCountryCallingCode;\n    metadata.selectNumberingPlan(country);\n    countryCallingCode = metadata.countryCallingCode();\n  } else {\n    countryCallingCode = countryOrCountryCallingCode;\n    /* istanbul ignore if */\n\n    if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n      if (metadata.isNonGeographicCallingCode(countryCallingCode)) {\n        country = '001';\n      }\n    }\n  }\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode\n  };\n}\nvar E164_NUMBER_REGEXP = /^\\+\\d+$/;","map":{"version":3,"names":["Metadata","validateMetadata","isPossibleNumber","isValidNumber","getNumberType","getPossibleCountriesForNumber","extractCountryCallingCode","isObject","formatNumber","USE_NON_GEOGRAPHIC_COUNTRY_CODE","PhoneNumber","countryOrCountryCallingCode","nationalNumber","metadata","_classCallCheck","TypeError","countries","e164Number","E164_NUMBER_REGEXP","test","Error","_extractCountryCallin","undefined","_countryCallingCode","countryCallingCode","number","_getCountryAndCountry","getCountryAndCountryCallingCode","country","getMetadata","setExt","ext","getPossibleCountries","isPossible","v2","isValid","isNonGeographic","isNonGeographicCallingCode","isEqual","phoneNumber","getType","format","_format","options","_objectSpread","formatNational","formatInternational","getURI","isCountryCode","value","metadataJson","selectNumberingPlan"],"sources":["C:\\Users\\MVclouds\\Desktop\\QuickForm\\Merged Mapping QF\\QuickForm\\QuickForm-Romit-Kajal-Merge\\quick-form-app\\node_modules\\libphonenumber-js\\source\\PhoneNumber.js"],"sourcesContent":["import Metadata, { validateMetadata } from './metadata.js'\r\nimport isPossibleNumber from './isPossible.js'\r\nimport isValidNumber from './isValid.js'\r\n// import checkNumberLength from './helpers/checkNumberLength.js'\r\nimport getNumberType from './helpers/getNumberType.js'\r\nimport getPossibleCountriesForNumber from './helpers/getPossibleCountriesForNumber.js'\r\nimport extractCountryCallingCode from './helpers/extractCountryCallingCode.js'\r\nimport isObject from './helpers/isObject.js'\r\nimport formatNumber from './format.js'\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\nexport default class PhoneNumber {\r\n\t/**\r\n\t * @param  {string} countryOrCountryCallingCode\r\n\t * @param  {string} nationalNumber\r\n\t * @param  {object} metadata — Metadata JSON\r\n\t * @return {PhoneNumber}\r\n\t */\r\n\tconstructor(countryOrCountryCallingCode, nationalNumber, metadata) {\r\n\t\t// Validate `countryOrCountryCallingCode` argument.\r\n\t\tif (!countryOrCountryCallingCode) {\r\n\t\t\tthrow new TypeError('First argument is required')\r\n\t\t}\r\n\t\tif (typeof countryOrCountryCallingCode !== 'string') {\r\n\t\t\tthrow new TypeError('First argument must be a string')\r\n\t\t}\r\n\r\n\t\t// In case of public API use: `constructor(number, metadata)`.\r\n\t\t// Transform the arguments from `constructor(number, metadata)` to\r\n\t\t// `constructor(countryOrCountryCallingCode, nationalNumber, metadata)`.\r\n\t\tif (typeof countryOrCountryCallingCode === 'string') {\r\n\t\t\tif (countryOrCountryCallingCode[0] === '+' && !nationalNumber) {\r\n\t\t\t\tthrow new TypeError('`metadata` argument not passed')\r\n\t\t\t}\r\n\t\t\tif (isObject(nationalNumber) && isObject(nationalNumber.countries)) {\r\n\t\t\t\tmetadata = nationalNumber\r\n\t\t\t\tconst e164Number = countryOrCountryCallingCode\r\n\t\t\t\tif (!E164_NUMBER_REGEXP.test(e164Number)) {\r\n\t\t\t\t\tthrow new Error('Invalid `number` argument passed: must consist of a \"+\" followed by digits')\r\n\t\t\t\t}\r\n\t\t\t\tconst { countryCallingCode, number } = extractCountryCallingCode(e164Number, undefined, undefined, metadata)\r\n\t\t\t\tnationalNumber = number\r\n\t\t\t\tcountryOrCountryCallingCode = countryCallingCode\r\n\t\t\t\tif (!nationalNumber) {\r\n\t\t\t\t\tthrow new Error('Invalid `number` argument passed: too short')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Validate `nationalNumber` argument.\r\n\t\tif (!nationalNumber) {\r\n\t\t\tthrow new TypeError('`nationalNumber` argument is required')\r\n\t\t}\r\n\t\tif (typeof nationalNumber !== 'string') {\r\n\t\t\tthrow new TypeError('`nationalNumber` argument must be a string')\r\n\t\t}\r\n\r\n\t\t// Validate `metadata` argument.\r\n\t\tvalidateMetadata(metadata)\r\n\r\n\t\t// Initialize properties.\r\n\t\tconst { country, countryCallingCode } = getCountryAndCountryCallingCode(\r\n\t\t\tcountryOrCountryCallingCode,\r\n\t\t\tmetadata\r\n\t\t)\r\n\t\tthis.country = country\r\n\t\tthis.countryCallingCode = countryCallingCode\r\n\t\tthis.nationalNumber = nationalNumber\r\n\t\tthis.number = '+' + this.countryCallingCode + this.nationalNumber\r\n\t\t// Exclude `metadata` property output from `PhoneNumber.toString()`\r\n\t\t// so that it doesn't clutter the console output of Node.js.\r\n\t\t// Previously, when Node.js did `console.log(new PhoneNumber(...))`,\r\n\t\t// it would output the whole internal structure of the `metadata` object.\r\n\t\tthis.getMetadata = () => metadata\r\n\t}\r\n\r\n\tsetExt(ext) {\r\n\t\tthis.ext = ext\r\n\t}\r\n\r\n\tgetPossibleCountries() {\r\n\t\tif (this.country) {\r\n\t\t\treturn [this.country]\r\n\t\t}\r\n\t\treturn getPossibleCountriesForNumber(\r\n\t\t\tthis.countryCallingCode,\r\n\t\t\tthis.nationalNumber,\r\n\t\t\tthis.getMetadata()\r\n\t\t)\r\n\t}\r\n\r\n\tisPossible() {\r\n\t\treturn isPossibleNumber(this, { v2: true }, this.getMetadata())\r\n\t}\r\n\r\n\tisValid() {\r\n\t\treturn isValidNumber(this, { v2: true }, this.getMetadata())\r\n\t}\r\n\r\n\tisNonGeographic() {\r\n\t\tconst metadata = new Metadata(this.getMetadata())\r\n\t\treturn metadata.isNonGeographicCallingCode(this.countryCallingCode)\r\n\t}\r\n\r\n\tisEqual(phoneNumber) {\r\n\t\treturn this.number === phoneNumber.number && this.ext === phoneNumber.ext\r\n\t}\r\n\r\n\t// This function was originally meant to be an equivalent for `validatePhoneNumberLength()`,\r\n\t// but later it was found out that it doesn't include the possible `TOO_SHORT` result\r\n\t// returned from `parsePhoneNumberWithError()` in the original `validatePhoneNumberLength()`,\r\n\t// so eventually I simply commented out this method from the `PhoneNumber` class\r\n\t// and just left the `validatePhoneNumberLength()` function, even though that one would require\r\n\t// and additional step to also validate the actual country / calling code of the phone number.\r\n\t// validateLength() {\r\n\t// \tconst metadata = new Metadata(this.getMetadata())\r\n\t// \tmetadata.selectNumberingPlan(this.countryCallingCode)\r\n\t// \tconst result = checkNumberLength(this.nationalNumber, metadata)\r\n\t// \tif (result !== 'IS_POSSIBLE') {\r\n\t// \t\treturn result\r\n\t// \t}\r\n\t// }\r\n\r\n\tgetType() {\r\n\t\treturn getNumberType(this, { v2: true }, this.getMetadata())\r\n\t}\r\n\r\n\tformat(format, options) {\r\n\t\treturn formatNumber(\r\n\t\t\tthis,\r\n\t\t\tformat,\r\n\t\t\toptions ? { ...options, v2: true } : { v2: true },\r\n\t\t\tthis.getMetadata()\r\n\t\t)\r\n\t}\r\n\r\n\tformatNational(options) {\r\n\t\treturn this.format('NATIONAL', options)\r\n\t}\r\n\r\n\tformatInternational(options) {\r\n\t\treturn this.format('INTERNATIONAL', options)\r\n\t}\r\n\r\n\tgetURI(options) {\r\n\t\treturn this.format('RFC3966', options)\r\n\t}\r\n}\r\n\r\nconst isCountryCode = (value) => /^[A-Z]{2}$/.test(value)\r\n\r\nfunction getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadataJson) {\r\n\tlet country\r\n\tlet countryCallingCode\r\n\r\n\tconst metadata = new Metadata(metadataJson)\r\n\t// If country code is passed then derive `countryCallingCode` from it.\r\n\t// Also store the country code as `.country`.\r\n\tif (isCountryCode(countryOrCountryCallingCode)) {\r\n\t\tcountry = countryOrCountryCallingCode\r\n\t\tmetadata.selectNumberingPlan(country)\r\n\t\tcountryCallingCode = metadata.countryCallingCode()\r\n\t} else {\r\n\t\tcountryCallingCode = countryOrCountryCallingCode\r\n\t\t/* istanbul ignore if */\r\n\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\tif (metadata.isNonGeographicCallingCode(countryCallingCode)) {\r\n\t\t\t\tcountry = '001'\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode\r\n\t}\r\n}\r\n\r\nconst E164_NUMBER_REGEXP = /^\\+\\d+$/"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}